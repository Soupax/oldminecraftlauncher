From c49f1697e5a9c3df89eb4d84c6bc6e9274361ef2 Mon Sep 17 00:00:00 2001
From: bigfoot547 <bigfoot@figboot.dev>
Date: Tue, 26 Apr 2022 01:03:39 -0500
Subject: [PATCH] Add skin editor + OptiFine cape editor


diff --git a/pom.xml b/pom.xml
index 7a17615..cae8c68 100644
--- a/pom.xml
+++ b/pom.xml
@@ -81,12 +81,6 @@
                                 <include>**</include>
                             </includes>
                         </filter>
-                        <filter>
-                            <artifact>*lwjgl*:*lwjgl*</artifact>
-                            <includes>
-                                <include>**</include>
-                            </includes>
-                        </filter>
                     </filters>
                     <createDependencyReducedPom>false</createDependencyReducedPom>
                     <transformers>
@@ -305,6 +299,44 @@
             <classifier>${lwjgl.natives}</classifier>
             <scope>compile</scope>
         </dependency>
+
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl</artifactId>
+            <classifier>natives-windows</classifier>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl-opengl</artifactId>
+            <classifier>natives-windows</classifier>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl-stb</artifactId>
+            <classifier>natives-windows</classifier>
+            <scope>compile</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl</artifactId>
+            <classifier>natives-windows-x86</classifier>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl-opengl</artifactId>
+            <classifier>natives-windows-x86</classifier>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl-stb</artifactId>
+            <classifier>natives-windows-x86</classifier>
+            <scope>compile</scope>
+        </dependency>
     </dependencies>
 
     <profiles>
diff --git a/src/main/java/dev/figboot/olauncher/OLauncherConstants.java b/src/main/java/dev/figboot/olauncher/OLauncherConstants.java
index e88d992..0b242a4 100644
--- a/src/main/java/dev/figboot/olauncher/OLauncherConstants.java
+++ b/src/main/java/dev/figboot/olauncher/OLauncherConstants.java
@@ -33,4 +33,7 @@ public final class OLauncherConstants {
     public static final String REDIR_URI = "http://localhost:" + REDIR_URI_PORT;
 
     public static final URL JRE_MANIFEST_URL = constantURL("https://launchermeta.mojang.com/v1/products/java-runtime/2ec0cc96c44e5a76b9c8b7c39df7210883d12871/all.json");
+
+    public static final URL STEVE_SKIN_URL = constantURL("http://textures.minecraft.net/texture/1a4af718455d4aab528e7a61f86fa25e6a369d1768dcb13f7df319a713eb810b");
+    public static final URL ALEX_SKIN_URL = constantURL("http://textures.minecraft.net/texture/3b60a1f6d562f52aaebbf1434f1de147933a3affe0e764fa49ea057536623cd3");
 }
diff --git a/src/main/java/dev/figboot/olauncher/auth/MCProfileInfo.java b/src/main/java/dev/figboot/olauncher/auth/MCProfileInfo.java
index b9a8ab6..0785a71 100644
--- a/src/main/java/dev/figboot/olauncher/auth/MCProfileInfo.java
+++ b/src/main/java/dev/figboot/olauncher/auth/MCProfileInfo.java
@@ -70,6 +70,24 @@ public class MCProfileInfo {
         }
     }
 
+    public Skin getActiveSkin() {
+        for (Skin skin : skins) {
+            if (skin.getState().equals("ACTIVE")) {
+                return skin;
+            }
+        }
+        return null;
+    }
+
+    public Cape getActiveCape() {
+        for (Cape cape : capes) {
+            if (cape.getState().equals("ACTIVE")) {
+                return cape;
+            }
+        }
+        return null;
+    }
+
     @Override
     public String toString() {
         return "MCProfileInfo{" +
diff --git a/src/main/java/dev/figboot/olauncher/auth/MicrosoftUserAuthentication.java b/src/main/java/dev/figboot/olauncher/auth/MicrosoftUserAuthentication.java
index b265375..8421bc0 100644
--- a/src/main/java/dev/figboot/olauncher/auth/MicrosoftUserAuthentication.java
+++ b/src/main/java/dev/figboot/olauncher/auth/MicrosoftUserAuthentication.java
@@ -209,8 +209,7 @@ public class MicrosoftUserAuthentication extends HttpUserAuthentication {
 
     private void profileLogIn() throws AuthenticationException {
         LOGGER.debug("Getting your user profile...");
-        profileInfo = getAuthenticationService().getAuthenticated(MicrosoftAuthenticationService.ROUTE_MINECRAFT_PROFILE,
-                mojToken, MCProfileInfo.class);
+        reloadProfileInfo();
 
         GameProfile profile = new GameProfile(profileInfo.getId(), profileInfo.getName());
         profile = sessionService.fillProfileProperties(profile, false);
@@ -280,6 +279,11 @@ public class MicrosoftUserAuthentication extends HttpUserAuthentication {
         return profileInfo;
     }
 
+    public void reloadProfileInfo() throws AuthenticationException {
+        profileInfo = getAuthenticationService().getAuthenticated(MicrosoftAuthenticationService.ROUTE_MINECRAFT_PROFILE,
+                mojToken, MCProfileInfo.class);
+    }
+
     @Override
     public void logOut() {
         super.logOut();
diff --git a/src/main/java/dev/figboot/olauncher/skin/ui/GLSkinViewer.java b/src/main/java/dev/figboot/olauncher/skin/ui/GLSkinViewer.java
new file mode 100644
index 0000000..9048540
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/skin/ui/GLSkinViewer.java
@@ -0,0 +1,542 @@
+/*
+ * OLauncher
+ * Copyright (C) 2022  bigfoot547 <olauncher@figboot.dev>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see https://github.com/olauncher/olauncher .
+ */
+
+package dev.figboot.olauncher.skin.ui;
+
+import dev.figboot.olauncher.skin.ui.gl.GLSkinViewerUtils;
+import dev.figboot.olauncher.skin.ui.model.MainBodyPart;
+import dev.figboot.olauncher.skin.ui.model.Model;
+import dev.figboot.olauncher.skin.ui.model.ModelSkinPart;
+import dev.figboot.olauncher.skin.ui.model.OverlayBodyPart;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.joml.Matrix4f;
+import org.joml.Vector3f;
+import org.joml.Vector4f;
+import org.lwjgl.opengl.GL;
+import org.lwjgl.opengl.GLCapabilities;
+import org.lwjgl.opengl.GLUtil;
+import org.lwjgl.opengl.awt.AWTGLCanvas;
+import org.lwjgl.opengl.awt.GLData;
+import org.lwjgl.system.MemoryStack;
+
+import java.awt.event.ComponentAdapter;
+import java.awt.event.ComponentEvent;
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.nio.Buffer;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.lwjgl.opengl.GL30.*;
+
+public class GLSkinViewer extends AWTGLCanvas {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private int program;
+
+    // uniform locations
+    private int projMatLoc, worldMatLoc, partMatLoc, lightPosLoc, flipNormalsLoc;
+    private int opaqueThreshLoc, allowTranslucentLoc;
+
+    private int skinTexture, capeTexture;
+
+    private Map<ModelSkinPart, Model> skinParts, overlayParts;
+    private Map<ModelSkinPart, Matrix4f> skinPartMats, overlayPartMats;
+
+    private boolean projMatDirty = false;
+    private Matrix4f projectionMatrix;
+
+    // stuff
+    private final Object dataLock = new Object();
+    private boolean skinLoaded = false;
+    private boolean textureDirty = false;
+    private BufferedImage skinImage, capeImage;
+    private boolean armTypeDirty = false;
+    private int armType = MainBodyPart.PART_ARM_NORMAL;
+
+    private boolean backgroundColorDirty = false;
+    private float bgColorR, bgColorG, bgColorB;
+
+    private boolean translucentOverlay = true;
+
+    private int overlayFlags = 0;
+
+    private float rotateX = (float)(Math.PI / 12), rotateY = (float)(-Math.PI / 4), rotateZ = 0;
+
+    private float limbRotateTimer = 0, capeRotateTimer = 0;
+    private float limbRotate = 0, capeRotate = 0;
+    private long lastFrameTime = 0;
+
+    private GLCapabilities caps;
+
+    public GLSkinViewer(GLData data) {
+        super(data);
+        initCalled = false;
+    }
+
+    @Override
+    public void initGL() {
+        synchronized (dataLock) {
+            LOGGER.info("Using OpenGL {}.{} (Profile: {}, Debug: {})", effective.majorVersion, effective.minorVersion, effective.profile, effective.debug);
+            caps = GL.createCapabilities();
+            GLUtil.setupDebugMessageCallback();
+
+            for (ModelSkinPart part : ModelSkinPart.values()) {
+                overlayFlags |= part.getFlag();
+            }
+
+            int[] ints = new int[2];
+            glGenTextures(ints);
+            skinTexture = ints[0];
+            capeTexture = ints[1];
+
+            glEnable(GL_TEXTURE_2D);
+
+            // Load shader program
+            //program = new ShaderProgram();
+            //program.init(gl);
+            //GLSkinViewerUtils.loadShaders(gl, program, getClass());
+            //program.useProgram(gl, true);
+            program = glCreateProgram();
+            try {
+                GLSkinViewerUtils.loadShaderProgram(program, getClass());
+            } catch (IOException ex) {
+                throw new RuntimeException("Unable to load shaders", ex);
+            }
+            glUseProgram(program);
+
+            glBindAttribLocation(program, 0, "vertPos");
+            glBindAttribLocation(program, 1, "inTexCoord");
+            glBindAttribLocation(program, 2, "normal");
+
+            projMatLoc = glGetUniformLocation(program, "projmat");
+            worldMatLoc = glGetUniformLocation(program, "worldmat");
+            partMatLoc = glGetUniformLocation(program, "partmat");
+            lightPosLoc = glGetUniformLocation(program, "lightPos");
+            flipNormalsLoc = glGetUniformLocation(program, "flipNormals");
+
+            opaqueThreshLoc = glGetUniformLocation(program, "opaqueThresh");
+            allowTranslucentLoc = glGetUniformLocation(program, "allowTranslucent");
+
+            skinParts = new EnumMap<>(ModelSkinPart.class);
+            overlayParts = new EnumMap<>(ModelSkinPart.class);
+
+            skinPartMats = new EnumMap<>(ModelSkinPart.class);
+            overlayPartMats = new EnumMap<>(ModelSkinPart.class);
+
+            glEnable(GL_DEPTH_TEST);
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+            Vector3f diffuseLightPos = new Vector3f(0, 0, -1).normalize();
+            glUniform3f(lightPosLoc, diffuseLightPos.x, diffuseLightPos.y, diffuseLightPos.z);
+            glUniform1i(flipNormalsLoc, 0);
+
+            /*try (InputStream is = getClass().getResourceAsStream("/figboot.png")) {
+                skinTexture = TextureIO.newTexture(is, false, "png").getTextureObject();
+            } catch (IOException ex) {
+                throw new RuntimeException(ex);
+            }
+
+            try (InputStream is = getClass().getResourceAsStream("/mojiramodcape.png")) {
+                capeTexture = TextureIO.newTexture(is, false, "png").getTextureObject();
+            } catch (IOException ex) {
+                throw new RuntimeException(ex);
+            }*/
+
+            handleResized(getFramebufferWidth(), getFramebufferHeight());
+
+            addComponentListener(new ComponentAdapter() {
+                @Override
+                public void componentResized(ComponentEvent e) {
+                    handleResized(getFramebufferWidth(), getFramebufferHeight());
+                }
+            });
+        }
+    }
+
+    private void destroyParts() {
+        Model model;
+        for (ModelSkinPart msp : ModelSkinPart.values()) {
+            model = skinParts.remove(msp);
+            if (model != null) model.destroy();
+
+            model = overlayParts.remove(msp);
+            if (model != null) model.destroy();
+        }
+
+        skinPartMats.clear();
+        overlayPartMats.clear();
+    }
+
+    @Override
+    public void disposeCanvas() {
+        if (caps == null) return;
+
+        int[] ints = new int[]{
+                skinTexture,
+                capeTexture
+        };
+
+        glDeleteTextures(ints);
+
+        destroyParts();
+        glDeleteProgram(program);
+
+        super.disposeCanvas();
+    }
+
+    @Override
+    public void paintGL() {
+        synchronized (dataLock) {
+            try {
+                drawFrame();
+            } finally {
+                swapBuffers();
+            }
+        }
+    }
+
+    private void loadImage(BufferedImage image) {
+        try (MemoryStack stack = MemoryStack.stackPush()) {
+            final int width = image.getWidth(), height = image.getHeight(), stride = width;
+            int[] rgbs = image.getRGB(0, 0, width, height, null, 0, stride);
+            ByteBuffer buf = stack.malloc(rgbs.length * (Integer.SIZE / 8));
+            int rgb;
+            for (int row = height - 1; row >= 0; --row) {
+                for (int col = 0; col < width; ++col) {
+                    rgb = rgbs[row * stride + col];
+                    buf.put((byte)((rgb >>> 16) & 0xFF));
+                    buf.put((byte)((rgb >>> 8) & 0xFF));
+                    buf.put((byte)(rgb & 0xFF));
+                    buf.put((byte)((rgb >>> 24) & 0xFF));
+                }
+            }
+            ((Buffer)buf).flip();
+
+            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image.getWidth(), image.getHeight(), 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+        }
+    }
+
+    private static final float MAX_TIMER = (float)(Math.PI * 2);
+    private void handleAnimation() {
+        if (lastFrameTime == 0) {
+            lastFrameTime = System.nanoTime();
+            return;
+        }
+
+        long now = System.nanoTime();
+        float deltaTimeMS = (now - lastFrameTime) / 1000000f;
+        lastFrameTime = now;
+
+        limbRotate = (float)(Math.sin(limbRotateTimer) * (Math.PI / 10));
+        limbRotateTimer += deltaTimeMS / 400;
+        while (limbRotateTimer > MAX_TIMER) limbRotateTimer -= MAX_TIMER;
+
+        capeRotate = (float)((Math.sin(capeRotateTimer) + 3.3) * (Math.PI / 40));
+        capeRotateTimer += deltaTimeMS / 1000;
+        while (capeRotateTimer > MAX_TIMER) capeRotateTimer -= MAX_TIMER;
+    }
+
+    private void drawFrame() {
+        if (textureDirty) {
+            if (skinImage != null) {
+                //loadTexImage(skinTexture, skinImage);
+                glBindTexture(GL_TEXTURE_2D, skinTexture);
+                loadImage(skinImage);
+                LOGGER.debug("Loaded skin texture");
+            }
+
+            if (capeImage != null) {
+                //loadTexImage(capeTexture, capeImage);
+                glBindTexture(GL_TEXTURE_2D, capeTexture);
+                loadImage(capeImage);
+                LOGGER.debug("Loaded cape texture");
+            }
+
+            skinLoaded = true;
+            textureDirty = false;
+        }
+
+        if (armTypeDirty) {
+            destroyParts();
+            LOGGER.debug("Arm type set (parts destroyed)");
+
+            armTypeDirty = false;
+        }
+
+        if (backgroundColorDirty) {
+            glClearColor(bgColorR, bgColorG, bgColorB, 1f);
+
+            backgroundColorDirty = false;
+        }
+
+        if (projMatDirty) {
+            try (MemoryStack stack = MemoryStack.stackPush()) {
+                glUniformMatrix4fv(projMatLoc, false, projectionMatrix.get(stack.mallocFloat(16)));
+            }
+            projMatDirty = false;
+        }
+
+        if (skinParts.isEmpty() || overlayParts.isEmpty()) {
+            if (skinLoaded && skinImage != null) {
+                LOGGER.debug("Model being created...");
+                Model model;
+                for (ModelSkinPart part : ModelSkinPart.values()) {
+                    if (part == ModelSkinPart.CAPE) {
+                        if (capeImage == null) continue;
+                        model = new MainBodyPart(part, capeImage.getHeight(), capeImage.getWidth(), armType);
+                    } else {
+                        model = new MainBodyPart(part, skinImage.getHeight(), skinImage.getWidth(), armType);
+                    }
+
+                    model.init();
+                    skinParts.put(part, model);
+                    skinPartMats.put(part, model.getSuggestedPartMatrix());
+
+                    if (part == ModelSkinPart.CAPE) continue;
+                    model = new OverlayBodyPart(part, skinImage.getHeight(), armType);
+                    model.init();
+                    overlayParts.put(part, model);
+                    overlayPartMats.put(part, model.getSuggestedPartMatrix());
+                }
+                LOGGER.debug("Model loaded");
+
+                limbRotateTimer = capeRotateTimer = 0;
+            } else {
+                LOGGER.debug("no rendering today :(");
+                return; // no rendering today :(
+            }
+        }
+
+        handleAnimation();
+
+        glEnableVertexAttribArray(0); // vertices
+        glEnableVertexAttribArray(1); // texture coordinates
+        glEnableVertexAttribArray(2); // normals
+
+        Matrix4f worldMatrix = new Matrix4f().identity();
+        float[] buf = new float[16]; // for uploading matrices to the GPU
+        worldMatrix.rotateXYZ(rotateX, rotateY, rotateZ);
+        glUniformMatrix4fv(worldMatLoc,false, worldMatrix.get(buf));
+
+        if (projectionMatrix == null) {
+            LOGGER.info("The projection matrix is not set up, skipping rendering for now.");
+            return;
+        }
+
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+        glUniform1f(opaqueThreshLoc, 0.5f);
+        glUniform1i(allowTranslucentLoc, 0);
+
+        glBindTexture(GL_TEXTURE_2D, skinTexture);
+
+        // render person
+        for (Map.Entry<ModelSkinPart, Model> entry : skinParts.entrySet()) {
+            Matrix4f partMat = skinPartMats.get(entry.getKey());
+            if (capeImage == null && entry.getKey() == ModelSkinPart.CAPE) continue;
+            else if (skinImage == null && entry.getKey() != ModelSkinPart.CAPE) continue;
+
+            switch (entry.getKey()) {
+                case LLEG:
+                case RARM:
+                    partMat = partMat.rotateX(-limbRotate, new Matrix4f());
+                    break;
+                case RLEG:
+                case LARM:
+                    partMat = partMat.rotateX(limbRotate, new Matrix4f());
+                    break;
+                case CAPE:
+                    if ((overlayFlags & ModelSkinPart.CAPE.getFlag()) == 0) continue;
+                    glBindTexture(GL_TEXTURE_2D, capeTexture);
+                    partMat = partMat.rotateX(capeRotate, new Matrix4f()).rotateY((float)Math.PI);
+            }
+
+            glUniformMatrix4fv(partMatLoc, false, partMat.get(buf));
+            entry.getValue().render();
+
+            if (entry.getKey() == ModelSkinPart.CAPE) {
+                glBindTexture(GL_TEXTURE_2D, skinTexture);
+            }
+        }
+
+        if (skinImage == null) return; // skip rendering overlay if the skin is not set
+        if (skinImage.getHeight() == 32) {
+            glEnable(GL_BLEND);
+            if ((overlayFlags & ModelSkinPart.HEAD.getFlag()) == 0) return;
+            Model head = overlayParts.get(ModelSkinPart.HEAD);
+            Matrix4f headPartMat = skinPartMats.get(ModelSkinPart.HEAD);
+
+            glUniformMatrix4fv(partMatLoc, false, headPartMat.get(buf));
+            head.render();
+            glDisable(GL_BLEND);
+        } else {
+            if (translucentOverlay) {
+                glUniform1f(opaqueThreshLoc, 1f);
+                glUniform1i(allowTranslucentLoc, 1);
+            }
+
+            glEnable(GL_BLEND);
+
+            List<Pair<Model, Matrix4f>> transparentParts = new ArrayList<>();
+            for (Map.Entry<ModelSkinPart, Model> entry : overlayParts.entrySet()) {
+                if ((overlayFlags & entry.getKey().getFlag()) == 0) continue;
+                Matrix4f partMat = overlayPartMats.get(entry.getKey());
+                transparentParts.add(new Pair<>(entry.getValue(), partMat));
+            }
+
+            if (projectionMatrix == null) LOGGER.info("projMat == null!");
+            Matrix4f factor = projectionMatrix.mul(worldMatrix, new Matrix4f());
+            transparentParts.sort((p1, p2) -> {
+                float depth1 = new Vector4f(0, 0, 1f, 1f).mul(factor.mul(p1.u, new Matrix4f())).z;
+                float depth2 = new Vector4f(0, 0, 1f, 1f).mul(factor.mul(p2.u, new Matrix4f())).z;
+                //float depth1 = new Vector4f(0, 0, 1f, 1f).mul(p1.u.mul(factor, new Matrix4f()), new Vector4f()).z;
+                //float depth2 = new Vector4f(0, 0, 1f, 1f).mul(p2.u.mul(factor, new Matrix4f()), new Vector4f()).z;
+                return Float.compare(depth1, depth2);
+            });
+
+            glEnable(GL_CULL_FACE);
+            glCullFace(GL_FRONT);
+            glUniform1i(flipNormalsLoc, 1);
+            for (Pair<Model, Matrix4f> part : transparentParts) {
+                glUniformMatrix4fv(partMatLoc, false, part.u.get(buf));
+                part.t.render();
+            }
+
+            glEnable(GL_CULL_FACE);
+            glCullFace(GL_BACK);
+            glUniform1i(flipNormalsLoc, 0);
+            for (Pair<Model, Matrix4f> part : transparentParts) {
+                glUniformMatrix4fv(partMatLoc, false, part.u.get(buf));
+                part.t.render();
+            }
+
+            glDisable(GL_CULL_FACE);
+            glDisable(GL_BLEND);
+        }
+    }
+
+    private void handleResized(int width, int height) {
+        if (width == 0 && height == 0) return;
+
+        synchronized (dataLock) {
+            float aspect = (float)height / width;
+
+            LOGGER.debug("loaded projection matrix");
+            projectionMatrix = new Matrix4f().ortho(-1, 1, -aspect, aspect, -4, 4);
+            projMatDirty = true;
+        }
+    }
+
+    public void setTextures(BufferedImage skinImage, BufferedImage capeImage) {
+        synchronized (dataLock) {
+            this.skinImage = skinImage;
+            this.capeImage = capeImage;
+            textureDirty = true;
+        }
+    }
+
+    public void setArmType(int armType) {
+        synchronized (dataLock) {
+            this.armType = armType;
+            armTypeDirty = true;
+        }
+    }
+
+    public void setBackgroundColor(float r, float g, float b) {
+        synchronized (dataLock) {
+            this.bgColorR = r;
+            this.bgColorG = g;
+            this.bgColorB = b;
+            backgroundColorDirty = true;
+        }
+    }
+
+    public void addRotation(float x, float y, float z) {
+        synchronized (dataLock) {
+            this.rotateX += x;
+            this.rotateY += y;
+            this.rotateZ += z;
+
+            if (rotateX < -Math.PI / 2) rotateX = (float)(-Math.PI / 2);
+            else if (rotateX > Math.PI / 2) rotateX = (float)(Math.PI / 2);
+        }
+    }
+
+    public void setTranslucentOverlay(boolean t) {
+        synchronized (dataLock) {
+            this.translucentOverlay = t;
+        }
+    }
+
+    public void setOverlayFlags(ModelSkinPart... parts) {
+        synchronized (dataLock) {
+            overlayFlags = 0;
+            addOverlayFlags(parts);
+        }
+    }
+
+    public void addOverlayFlags(ModelSkinPart... parts) {
+        synchronized (dataLock) {
+            for (ModelSkinPart part : parts) {
+                overlayFlags |= part.getFlag();
+            }
+        }
+    }
+
+    public void resetOverlayFlags(ModelSkinPart... parts) {
+        int i = 0;
+        for (ModelSkinPart part : parts) {
+            i |= part.getFlag();
+        }
+
+        synchronized (dataLock) {
+            overlayFlags &= ~i;
+        }
+    }
+
+    public void clearOverlayFlags() {
+        synchronized (dataLock) {
+            overlayFlags = 0;
+        }
+    }
+
+    public boolean getOverlayFlag(ModelSkinPart part) {
+        synchronized (dataLock) {
+            return (overlayFlags & part.getFlag()) != 0;
+        }
+    }
+
+    private static class Pair<T, U> {
+        public T t;
+        public U u;
+
+        public Pair(T t, U u) {
+            this.t = t;
+            this.u = u;
+        }
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/skin/ui/SkinEditorTab.java b/src/main/java/dev/figboot/olauncher/skin/ui/SkinEditorTab.java
new file mode 100644
index 0000000..0787acd
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/skin/ui/SkinEditorTab.java
@@ -0,0 +1,231 @@
+/*
+ * OLauncher
+ * Copyright (C) 2022  bigfoot547 <olauncher@figboot.dev>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see https://github.com/olauncher/olauncher .
+ */
+
+package dev.figboot.olauncher.skin.ui;
+
+import com.mojang.authlib.UserAuthentication;
+import com.mojang.launcher.OperatingSystem;
+import dev.figboot.olauncher.auth.MCProfileInfo;
+import dev.figboot.olauncher.auth.MicrosoftUserAuthentication;
+import dev.figboot.olauncher.skin.ui.model.MainBodyPart;
+import dev.figboot.olauncher.skin.ui.model.ModelSkinPart;
+import lombok.Getter;
+import lombok.RequiredArgsConstructor;
+import net.minecraft.launcher.Launcher;
+import net.minecraft.launcher.profile.ProfileManager;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.lwjgl.opengl.awt.GLData;
+
+import javax.imageio.ImageIO;
+import javax.swing.*;
+import java.awt.*;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseMotionListener;
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.net.URL;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.UUID;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+public class SkinEditorTab extends JPanel {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    @Getter private final UUID playerUuid;
+
+    private final Launcher launcher;
+    private final GLSkinViewer viewer;
+
+    private final ScheduledFuture<?> frameUpdateFuture;
+
+    private final Object downloadedTexturesLock = new Object();
+    private final Map<UUID, DownloadedSkin> downloadedSkins;
+    private final Map<UUID, DownloadedCape> downloadedCapes;
+
+    private UUID activeSkin;
+    private UUID activeCape;
+
+    public SkinEditorTab(Launcher launcher, ScheduledExecutorService executorService, MCProfileInfo mcProfile) {
+        this.playerUuid = mcProfile.getId();
+        this.launcher = launcher;
+
+        setLayout(new FlowLayout());
+        GLData glData = new GLData();
+
+        if (System.getProperty("dev.figboot.olauncher.GLSkinViewer.debugGL", "false").equalsIgnoreCase("true")) {
+            glData.debug = true;
+        }
+
+        viewer = new GLSkinViewer(glData);
+        viewer.setPreferredSize(new Dimension(200, 300));
+        add(viewer);
+
+        MouseListener ml = new MouseListener();
+        viewer.addMouseListener(ml);
+        viewer.addMouseMotionListener(ml);
+
+        viewer.setTranslucentOverlay(true);
+        viewer.setBackgroundColor(.8f, .8f, .8f);
+
+        JCheckBox cb = new JCheckBox("transgender");
+        cb.addActionListener(e -> viewer.setTranslucentOverlay(cb.isSelected()));
+
+        JButton ofCapeEdit = new JButton("OptiFine Cape Editor");
+        ofCapeEdit.addActionListener(e -> {
+            MicrosoftUserAuthentication auth = null;
+
+            {
+                ProfileManager pman = launcher.getProfileManager();
+                UserAuthentication uAuth = pman.getAuthDatabase().getByUUID(pman.getSelectedUser());
+                if (uAuth instanceof MicrosoftUserAuthentication) auth = (MicrosoftUserAuthentication)uAuth;
+            }
+
+            try {
+                OperatingSystem.openLink(auth.createOptiFineCapeEditor().toURI());
+            } catch (Exception ex) {
+                throw new RuntimeException(ex);
+            }
+        });
+
+        add(cb);
+        add(ofCapeEdit);
+        System.out.println(mcProfile);
+
+        downloadedSkins = new TreeMap<>();
+        downloadedCapes = new TreeMap<>();
+
+        revalidate();
+        frameUpdateFuture = executorService.scheduleAtFixedRate(() -> SwingUtilities.invokeLater(() -> {
+            if (isVisible()) {
+                try {
+                    viewer.render();
+                } catch (Exception ex) {
+                    LOGGER.error("Exception while rendering frame", ex);
+                }
+            }
+        }), 50, 1000 / 50, TimeUnit.MILLISECONDS);
+
+        executorService.submit(() -> queryTextures(mcProfile));
+    }
+
+    public void queryTextures(MCProfileInfo profileInfo) {
+        MicrosoftUserAuthentication auth = null;
+        {
+            ProfileManager pman = launcher.getProfileManager();
+            UserAuthentication uAuth = pman.getAuthDatabase().getByUUID(pman.getSelectedUser());
+            if (uAuth instanceof MicrosoftUserAuthentication) auth = (MicrosoftUserAuthentication)uAuth;
+        }
+
+        synchronized (downloadedTexturesLock) {
+            for (MCProfileInfo.Skin skin : profileInfo.getSkins()) {
+                if (skin.getState().equals("ACTIVE")) activeSkin = skin.getId();
+                if (!downloadedSkins.containsKey(skin.getId())) {
+                    DownloadedSkin skinDL;
+                    try {
+                        LOGGER.info("Downloading skin: {} (alias {})", new Object[]{skin.getId(), skin.getAlias()});
+                        skinDL = new DownloadedSkin(skin, ImageIO.read(new URL(skin.getUrl())), skin.getVariant().equals("CLASSIC") ? MainBodyPart.PART_ARM_NORMAL : MainBodyPart.PART_ARM_SLIM);
+                        downloadedSkins.put(skin.getId(), skinDL);
+                    } catch (IOException ex) {
+                        LOGGER.error("Error downloading skin " + skin.getId() + " (alias " + skin.getAlias() + ")", ex);
+                    }
+                }
+            }
+
+            for (MCProfileInfo.Cape cape : profileInfo.getCapes()) {
+                /*if (cape.getState().equals("ACTIVE"))*/ activeCape = cape.getId();
+                if (!downloadedCapes.containsKey(cape.getId())) {
+                    DownloadedCape capeDL;
+                    try {
+                        LOGGER.info("Downloading cape: {} (alias {})", new Object[]{cape.getId(), cape.getAlias()});
+                        capeDL = new DownloadedCape(cape, ImageIO.read(new URL(cape.getUrl())));
+                        downloadedCapes.put(cape.getId(), capeDL);
+                    } catch (IOException ex) {
+                        LOGGER.error("Error downloading cape " + cape.getId() + " (alias " + cape.getAlias() + ")", ex);
+                    }
+                }
+            }
+
+            DownloadedSkin dlSkin = activeSkin != null ? downloadedSkins.get(activeSkin) : null;
+            DownloadedCape dlCape = activeCape != null ? downloadedCapes.get(activeCape) : null;
+            viewer.setTextures(dlSkin == null ? null : dlSkin.image, dlCape == null ? null : dlCape.image);
+
+            if (dlSkin != null) {
+                viewer.setArmType(dlSkin.skinParam);
+                if (dlSkin.image.getHeight() == 32) {
+                    viewer.setOverlayFlags(ModelSkinPart.HEAD);
+                }
+            }
+        }
+    }
+
+    public void shutdown() {
+        frameUpdateFuture.cancel(true);
+    }
+
+    private class MouseListener extends MouseAdapter implements MouseMotionListener {
+        private Point lastPos;
+
+        private MouseListener() { }
+
+        @Override
+        public void mouseDragged(MouseEvent e) {
+            Point pos = e.getPoint();
+            if (lastPos == null) {
+                lastPos = pos;
+                return;
+            }
+
+            int deltaX = pos.x - lastPos.x;
+            int deltaY = pos.y - lastPos.y;
+
+            viewer.addRotation(deltaY / 75f, deltaX / 75f, 0);
+            lastPos = pos;
+        }
+
+        @Override
+        public void mouseReleased(MouseEvent e) {
+            lastPos = null;
+        }
+    }
+
+    @RequiredArgsConstructor
+    private static class DownloadedSkin {
+        private final MCProfileInfo.Skin skin;
+        private final BufferedImage image;
+        private final int skinParam;
+    }
+
+    @RequiredArgsConstructor
+    private static class DownloadedCape {
+        private final MCProfileInfo.Cape cape;
+        private final BufferedImage image;
+
+        @Override
+        public String toString() {
+            return "DownloadedCape{" +
+                    "cape=" + cape +
+                    ", image=" + image +
+                    '}';
+        }
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/skin/ui/gl/GLSkinViewerUtils.java b/src/main/java/dev/figboot/olauncher/skin/ui/gl/GLSkinViewerUtils.java
new file mode 100644
index 0000000..a0b7e42
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/skin/ui/gl/GLSkinViewerUtils.java
@@ -0,0 +1,104 @@
+/*
+ * OLauncher
+ * Copyright (C) 2022  bigfoot547 <olauncher@figboot.dev>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see https://github.com/olauncher/olauncher .
+ */
+
+package dev.figboot.olauncher.skin.ui.gl;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.util.Objects;
+
+import static org.lwjgl.opengl.GL30.*;
+
+public class GLSkinViewerUtils {
+    private GLSkinViewerUtils() { }
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private static int loadShader(Class<?> clazz, String resource, int type) throws IOException {
+        LOGGER.debug("Loading shader: {}", resource);
+        String source;
+        try (InputStream is = Objects.requireNonNull(clazz.getResourceAsStream(resource))) {
+            source = IOUtils.toString(is, StandardCharsets.UTF_8);
+        }
+
+        LOGGER.debug("Compiling shader: {}", resource);
+        int shader = glCreateShader(type);
+        glShaderSource(shader, source);
+        glCompileShader(shader);
+        int status = glGetShaderi(shader, GL_COMPILE_STATUS);
+        if (status != GL_TRUE) {
+            String infoLog = glGetShaderInfoLog(status);
+            LOGGER.error("Error compiling " + resource + ":");
+            LOGGER.error(infoLog);
+            throw new RuntimeException(resource + " shader compilation failed");
+        }
+        LOGGER.debug("Shader {} compiled successfully", resource);
+        return shader;
+    }
+
+    public static void loadShaderProgram(int program, Class<?> resClass) throws IOException {
+        int vertShader = loadShader(resClass, "vert.glsl", GL_VERTEX_SHADER);
+        int fragShader = loadShader(resClass, "frag.glsl", GL_FRAGMENT_SHADER);
+
+        glAttachShader(program, vertShader);
+        glAttachShader(program, fragShader);
+
+        glLinkProgram(program);
+        int status = glGetProgrami(program, GL_LINK_STATUS);
+        if (status != GL_TRUE) {
+            String log = glGetProgramInfoLog(program);
+            LOGGER.error("Error linking shader program:");
+            LOGGER.error(log);
+            throw new RuntimeException("Shader program linking failed");
+        }
+
+        glDeleteShader(vertShader);
+        glDeleteShader(fragShader);
+    }
+
+    /*public static void loadShaders(GL3 gl, ShaderProgram program, Class<?> resClass) {
+        ShaderCode vertShader = ShaderCode.create(gl, GL3.GL_VERTEX_SHADER, 1, resClass, new String[]{"vert.glsl"}, false);
+        ShaderCode fragShader = ShaderCode.create(gl, GL3.GL_FRAGMENT_SHADER, 1, resClass, new String[]{"frag.glsl"}, false);
+
+        LOGGER.debug("Compiling vertex shader...");
+        if (!vertShader.compile(gl, System.err)) {
+            throw new RuntimeException("Error compiling vertex shader");
+        }
+
+        LOGGER.debug("Compiling fragment shader...");
+        if (!fragShader.compile(gl, System.err)) {
+            throw new RuntimeException("Error compiling fragment shader");
+        }
+
+        program.add(vertShader);
+        program.add(fragShader);
+
+        LOGGER.debug("Linking fragment shader...");
+        if (!program.link(gl, System.err)) {
+            throw new RuntimeException("Error linking shader program");
+        }
+
+        vertShader.destroy(gl);
+        fragShader.destroy(gl);
+    }*/
+}
diff --git a/src/main/java/dev/figboot/olauncher/skin/ui/model/MainBodyPart.java b/src/main/java/dev/figboot/olauncher/skin/ui/model/MainBodyPart.java
new file mode 100644
index 0000000..b256385
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/skin/ui/model/MainBodyPart.java
@@ -0,0 +1,118 @@
+/*
+ * OLauncher
+ * Copyright (C) 2022  bigfoot547 <olauncher@figboot.dev>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see https://github.com/olauncher/olauncher .
+ */
+
+package dev.figboot.olauncher.skin.ui.model;
+
+import org.joml.Matrix4f;
+import org.joml.Vector3f;
+
+public class MainBodyPart extends Model {
+    private final float[] verts, normals, texCoords;
+
+    private final int vertCount, normalCount, texCoordCount;
+
+    public static final int PART_ARM_NORMAL = 0, PART_ARM_SLIM = 1;
+
+    private final Matrix4f partMat;
+
+    public MainBodyPart(ModelSkinPart part, int texHeight, int texWidth, int partInfo) {
+        ModelBuilder mb = new ModelBuilder();
+
+        switch (part) {
+            case HEAD:
+                mb.addCube(new Vector3f(-4f/16, -4f/16, -4f/16), new Vector3f(4f/16, 4f/16, 4f/16),
+                        ModelBuilder.boxTexCoords(8f/64, 1 - 16f/texHeight, 8f/64, 8f/texHeight, 8f/64, 8f/texHeight));
+                partMat = new Matrix4f().identity().translate(0, 12f/16, 0);
+                break;
+            case BODY:
+                mb.addCube(new Vector3f(-4f/16, -6f/16, -2f/16), new Vector3f(4f/16, 6f/16, 2f/16),
+                        ModelBuilder.boxTexCoords(20f/64, 1 - 32f/texHeight, 8f/64, 12f/texHeight, 4f/64, 4f/texHeight));
+                partMat = new Matrix4f().identity().translate(0, 2f/16, 0);
+                break;
+            case RARM:
+                mb.addCube(new Vector3f(partInfo == PART_ARM_NORMAL ? -2f/16 : -1f/16, -10f/16, -2f/16), new Vector3f(2f/16, 2f/16, 2f/16),
+                        ModelBuilder.boxTexCoords(44f/64, 1 - 32f/texHeight, partInfo == PART_ARM_NORMAL ? 4f/64 : 3f/64, 12f/texHeight, 4f/64, 4f/texHeight));
+                partMat = new Matrix4f().identity().translate(-6f/16, 6f/16, 0);
+                break;
+            case LARM:
+                mb.addCube(new Vector3f(-2f/16, -10f/16, -2f/16), new Vector3f(partInfo == PART_ARM_NORMAL ? 2f/16 : 1f/16, 2f/16, 2f/16),
+                        ModelBuilder.boxTexCoords(texHeight == 64 ? 36f/64 : 44f/64, texHeight == 64 ? 1 - 64f/64 : 1 - 32f/32, partInfo == PART_ARM_NORMAL ? 4f/64 : 3f/64, 12f/texHeight, 4f/64, 4f/texHeight));
+                partMat = new Matrix4f().identity().translate(6f/16, 6f/16, 0);
+                break;
+            case RLEG:
+                mb.addCube(new Vector3f(-2f/16, -12f/16, -2f/16), new Vector3f(2f/16, 0, 2f/16),
+                        ModelBuilder.boxTexCoords(4f/64, 1 - 32f/texHeight, 4f/64, 12f/texHeight, 4f/64, 4f/texHeight));
+                partMat = new Matrix4f().identity().translate(-2f/16, -4f/16, 0);
+                break;
+            case LLEG:
+                mb.addCube(new Vector3f(-2f/16, -12f/16, -2f/16), new Vector3f(2f/16, 0, 2f/16),
+                        ModelBuilder.boxTexCoords(texHeight == 64 ? 20f/64 : 4f/64, texHeight == 64 ? 1 - 64f/64 : 1 - 32f/32, 4f/64, 12f/texHeight, 4f/64, 4f/texHeight));
+                partMat = new Matrix4f().identity().translate(2f/16, -4f/16, 0);
+                break;
+            case CAPE:
+                mb.addCube(new Vector3f(-5f/16, -16f/16, 0), new Vector3f(5f/16, 0, 1f/16),
+                        ModelBuilder.boxTexCoords(1f/texWidth, 1 - 17f/texHeight, 10f/texWidth, 16f/texHeight, 1f/texWidth, 1f/texHeight));
+                partMat = new Matrix4f().identity().translate(0, 8f/16, -2f/16);
+                break;
+            default:
+                throw new IllegalArgumentException("Invalid model part specified");
+        }
+
+        verts = mb.getVerts();
+        normals = mb.getNormals();
+        texCoords = mb.getTexCoords();
+        vertCount = mb.getVertCount();
+        normalCount = mb.getNormalCount();
+        texCoordCount = mb.getTexCoordCount();
+    }
+
+    @Override
+    protected float[] getVertices() {
+        return verts;
+    }
+
+    @Override
+    protected float[] getTexCoords() {
+        return texCoords;
+    }
+
+    @Override
+    protected float[] getNormals() {
+        return normals;
+    }
+
+    @Override
+    protected int getVertexCount() {
+        return vertCount;
+    }
+
+    @Override
+    protected int getNormalCount() {
+        return normalCount;
+    }
+
+    @Override
+    protected int getTexCoordCount() {
+        return texCoordCount;
+    }
+
+    @Override
+    public Matrix4f getSuggestedPartMatrix() {
+        return new Matrix4f(partMat);
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/skin/ui/model/Model.java b/src/main/java/dev/figboot/olauncher/skin/ui/model/Model.java
new file mode 100644
index 0000000..ff9669f
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/skin/ui/model/Model.java
@@ -0,0 +1,92 @@
+/*
+ * OLauncher
+ * Copyright (C) 2022  bigfoot547 <olauncher@figboot.dev>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see https://github.com/olauncher/olauncher .
+ */
+
+package dev.figboot.olauncher.skin.ui.model;
+
+import org.joml.Matrix4f;
+
+import static org.lwjgl.opengl.GL30.*;
+
+public abstract class Model {
+    private int vao;
+    private int vboVert, vboTex, vboNormal;
+
+    public Model() { }
+
+    public void init() {
+        int[] ints1 = new int[1];
+        int[] ints2 = new int[3];
+        glGenVertexArrays(ints1);
+        vao = ints1[0];
+
+        glGenBuffers(ints2);
+        vboVert = ints2[0];
+        vboTex = ints2[1];
+        vboNormal = ints2[2];
+
+        loadModel();
+    }
+
+    public void destroy() {
+        int[] ints1 = new int[1];
+        int[] ints2 = new int[3];
+        ints1[0] = vao;
+        glDeleteVertexArrays(ints1);
+
+        ints2[0] = vboVert;
+        ints2[1] = vboTex;
+        ints2[2] = vboNormal;
+        glDeleteBuffers(ints2);
+    }
+
+    protected abstract float[] getVertices();
+    protected abstract float[] getTexCoords();
+    protected abstract float[] getNormals();
+
+    protected abstract int getVertexCount();
+    protected abstract int getTexCoordCount();
+    protected abstract int getNormalCount();
+
+    public Matrix4f getSuggestedPartMatrix() {
+        return new Matrix4f().identity();
+    }
+
+    protected void loadModel() {
+        glBindVertexArray(vao);
+        glBindBuffer(GL_ARRAY_BUFFER, vboVert);
+        glVertexAttribPointer(0, 3, GL_FLOAT, false, 0, 0);
+        glBufferData(GL_ARRAY_BUFFER, getVertices(), GL_STATIC_DRAW);
+
+        glBindBuffer(GL_ARRAY_BUFFER, vboTex);
+        glVertexAttribPointer(1, 2, GL_FLOAT, false, 0, 0);
+        glBufferData(GL_ARRAY_BUFFER, getTexCoords(), GL_STATIC_DRAW);
+
+        glBindBuffer(GL_ARRAY_BUFFER, vboNormal);
+        glVertexAttribPointer(2, 3, GL_FLOAT, false, 0, 0);
+        glBufferData(GL_ARRAY_BUFFER, getNormals(), GL_STATIC_DRAW);
+    }
+
+    public void render() {
+        glBindVertexArray(vao);
+        glEnableVertexAttribArray(0);
+        glEnableVertexAttribArray(1);
+        glEnableVertexAttribArray(2);
+
+        glDrawArrays(GL_TRIANGLES, 0, getVertexCount());
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/skin/ui/model/ModelBuilder.java b/src/main/java/dev/figboot/olauncher/skin/ui/model/ModelBuilder.java
new file mode 100644
index 0000000..a27dad7
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/skin/ui/model/ModelBuilder.java
@@ -0,0 +1,208 @@
+/*
+ * OLauncher
+ * Copyright (C) 2022  bigfoot547 <olauncher@figboot.dev>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see https://github.com/olauncher/olauncher .
+ */
+
+package dev.figboot.olauncher.skin.ui.model;
+
+import org.joml.Vector2f;
+import org.joml.Vector3f;
+
+import java.util.ArrayList;
+import java.util.List;
+
+class ModelBuilder {
+    private final List<Float> vertVals;
+    private final List<Float> texCoordVals;
+    private final List<Float> normalVals;
+
+    public ModelBuilder() {
+        vertVals = new ArrayList<>();
+        texCoordVals = new ArrayList<>();
+        normalVals = new ArrayList<>();
+    }
+
+    public void addTri(Vector3f p1, Vector3f p2, Vector3f p3, Vector2f t1, Vector2f t2, Vector2f t3, boolean invertNormals) {
+        vertVals.add(p1.x);
+        vertVals.add(p1.y);
+        vertVals.add(p1.z);
+        vertVals.add(p2.x);
+        vertVals.add(p2.y);
+        vertVals.add(p2.z);
+        vertVals.add(p3.x);
+        vertVals.add(p3.y);
+        vertVals.add(p3.z);
+
+        texCoordVals.add(t1.x);
+        texCoordVals.add(t1.y);
+        texCoordVals.add(t2.x);
+        texCoordVals.add(t2.y);
+        texCoordVals.add(t3.x);
+        texCoordVals.add(t3.y);
+
+        Vector3f normals = (p1.sub(p3, new Vector3f()).cross(p1.sub(p2, new Vector3f()), new Vector3f())).normalize();
+        if (invertNormals) normals.mul(-1);
+        normalVals.add(normals.x);
+        normalVals.add(normals.y);
+        normalVals.add(normals.z);
+        normalVals.add(normals.x);
+        normalVals.add(normals.y);
+        normalVals.add(normals.z);
+        normalVals.add(normals.x);
+        normalVals.add(normals.y);
+        normalVals.add(normals.z);
+    }
+
+    public void addVParallelogram(Vector3f c1, Vector3f c2, Vector2f tc1, Vector2f tc2, boolean invertNormals) {
+        // c3   c2
+        //
+        // c1   c4
+
+        Vector3f c3 = new Vector3f(c1.x, c2.y, c1.z);
+        Vector3f c4 = new Vector3f(c2.x, c1.y, c2.z);
+
+        Vector2f tc3 = new Vector2f(tc1.x, tc2.y);
+        Vector2f tc4 = new Vector2f(tc2.x, tc1.y);
+
+        addTri(c2, c3, c1, tc2, tc3, tc1, invertNormals);
+        addTri(c1, c4, c2, tc1, tc4, tc2, invertNormals);
+    }
+
+    public void addHParallelogram(Vector3f c1, Vector3f c2, Vector2f tc1, Vector2f tc2, boolean invertNormals) {
+        // c3    c2
+        //   c1    c4
+
+        Vector3f c3 = new Vector3f(c1.x, c1.y, c2.z);
+        Vector3f c4 = new Vector3f(c2.x, c2.y, c1.z);
+
+        Vector2f tc3 = new Vector2f(tc1.x, tc2.y);
+        Vector2f tc4 = new Vector2f(tc2.x, tc1.y);
+
+        addTri(c2, c3, c1, tc2, tc3, tc1, invertNormals);
+        addTri(c1, c4, c2, tc1, tc4, tc2, invertNormals);
+    }
+
+    public void addCube(Vector3f c1, Vector3f c2, Vector2f[] faceTexCoords) {
+        // c3    c2
+        //   c7    c6
+        //
+        // c4    c5
+        //   c1    c8
+
+        Vector3f c3 = new Vector3f(c1.x, c2.y, c2.z);
+        Vector3f c4 = new Vector3f(c1.x, c1.y, c2.z);
+        Vector3f c5 = new Vector3f(c2.x, c1.y, c2.z);
+        Vector3f c6 = new Vector3f(c2.x, c2.y, c1.z);
+        Vector3f c7 = new Vector3f(c1.x, c2.y, c1.z);
+        Vector3f c8 = new Vector3f(c2.x, c1.y, c1.z);
+
+        addVParallelogram(c4, c2, faceTexCoords[0], faceTexCoords[1], false);
+        addVParallelogram(c5, c6, faceTexCoords[2], faceTexCoords[3], false);
+        addVParallelogram(c8, c7, faceTexCoords[4], faceTexCoords[5], false);
+        addVParallelogram(c1, c3, faceTexCoords[6], faceTexCoords[7], false);
+        addHParallelogram(c3, c6, faceTexCoords[8], faceTexCoords[9], false);
+        addHParallelogram(c4, c8, faceTexCoords[10], faceTexCoords[11], true);
+    }
+
+    private float[] unboxList(List<Float> floatList) {
+        int idx = 0;
+        float[] ret = new float[floatList.size()];
+        for (float f : floatList) {
+            ret[idx++] = f;
+        }
+        return ret;
+    }
+
+    /*public FloatBuffer getVerts() {
+        FloatBuffer fb = FloatBuffer.allocate(vertVals.size());
+        for (float f : vertVals) {
+            fb.put(f);
+        }
+        ((Buffer)fb).flip();
+        return fb;
+    }
+
+    public float[] getTexCoords() {
+        FloatBuffer fb = FloatBuffer.allocate(texCoordVals.size());
+        for (float f : texCoordVals) {
+            fb.put(f);
+        }
+        ((Buffer)fb).flip();
+        return fb;
+    }
+
+    public FloatBuffer getNormals() {
+        FloatBuffer fb = FloatBuffer.allocate(normalVals.size());
+        for (float f : normalVals) {
+            fb.put(f);
+        }
+        ((Buffer)fb).flip();
+        return fb;
+    }*/
+
+    public float[] getVerts() {
+        return unboxList(vertVals);
+    }
+
+    public float[] getTexCoords() {
+        return unboxList(texCoordVals);
+    }
+
+    public float[] getNormals() {
+        return unboxList(normalVals);
+    }
+
+    public int getVertCount() {
+        return vertVals.size();
+    }
+
+    public int getTexCoordCount() {
+        return texCoordVals.size();
+    }
+
+    public int getNormalCount() {
+        return normalVals.size();
+    }
+
+    public static Vector2f[] boxTexCoords(float xBase, float yBase, float width, float height, float depth, float depthY) {
+        Vector2f[] arr = new Vector2f[]{
+                // top
+                new Vector2f(xBase, yBase),
+                new Vector2f(xBase + width, yBase + height),
+
+                // right
+                new Vector2f(xBase + width, yBase),
+                new Vector2f(xBase + width + depth, yBase + height),
+
+                // back
+                new Vector2f(xBase + width + depth, yBase),
+                new Vector2f(xBase + 2 * width + depth, yBase + height),
+
+                // left
+                new Vector2f(xBase - depth, yBase),
+                new Vector2f(xBase, yBase + height),
+
+                // top
+                new Vector2f(xBase, yBase + height),
+                new Vector2f(xBase + width, yBase + height + depthY),
+
+                // bottom
+                new Vector2f(xBase + width, yBase + height),
+                new Vector2f(xBase + 2 * width, yBase + height + depthY),
+        };
+        return arr;
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/skin/ui/model/ModelSkinPart.java b/src/main/java/dev/figboot/olauncher/skin/ui/model/ModelSkinPart.java
new file mode 100644
index 0000000..a58c080
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/skin/ui/model/ModelSkinPart.java
@@ -0,0 +1,37 @@
+/*
+ * OLauncher
+ * Copyright (C) 2022  bigfoot547 <olauncher@figboot.dev>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see https://github.com/olauncher/olauncher .
+ */
+
+package dev.figboot.olauncher.skin.ui.model;
+
+import lombok.Getter;
+
+public enum ModelSkinPart {
+    HEAD(1),
+    BODY(2),
+    RARM(4),
+    LARM(8),
+    RLEG(16),
+    LLEG(32),
+    CAPE(64);
+
+    @Getter private final int flag;
+
+    ModelSkinPart(int flag) {
+        this.flag = flag;
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/skin/ui/model/OverlayBodyPart.java b/src/main/java/dev/figboot/olauncher/skin/ui/model/OverlayBodyPart.java
new file mode 100644
index 0000000..db79bc0
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/skin/ui/model/OverlayBodyPart.java
@@ -0,0 +1,117 @@
+/*
+ * OLauncher
+ * Copyright (C) 2022  bigfoot547 <olauncher@figboot.dev>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see https://github.com/olauncher/olauncher .
+ */
+
+package dev.figboot.olauncher.skin.ui.model;
+
+import org.joml.Matrix4f;
+import org.joml.Vector3f;
+
+public class OverlayBodyPart extends Model {
+    private final float[] verts, normals, texCoords;
+
+    private final int vertCount, normalCount, texCoordCount;
+
+    public static final int PART_ARM_NORMAL = 0, PART_ARM_SLIM = 1;
+    private static final float ZFIGHT_OFFSET = 0;
+    private static final float OVERLAY_OFFSET = 0.25f / 16f;
+    private static final float HEAD_OVERLAY_OFFSET = 0.5f / 16f;
+
+    private final Matrix4f partMat;
+
+    public OverlayBodyPart(ModelSkinPart part, int texHeight, int partInfo) {
+        ModelBuilder mb = new ModelBuilder();
+        if (part == ModelSkinPart.CAPE) throw new IllegalArgumentException("Capes do not have an overlay");
+
+        switch (part) {
+            case HEAD:
+                mb.addCube(new Vector3f(-4f/16 - HEAD_OVERLAY_OFFSET, -4f/16 - HEAD_OVERLAY_OFFSET, -4f/16 - HEAD_OVERLAY_OFFSET), new Vector3f(4f/16 + HEAD_OVERLAY_OFFSET, 4f/16 + HEAD_OVERLAY_OFFSET, 4f/16 + HEAD_OVERLAY_OFFSET),
+                        ModelBuilder.boxTexCoords(40f/64, 1 - 16f/texHeight, 8f/64, 8f/texHeight, 8f/64, 8f/texHeight));
+                partMat = new Matrix4f().identity().translate(0, 12f/16, 0);
+                break;
+            case BODY:
+                mb.addCube(new Vector3f(-4f/16 - OVERLAY_OFFSET, -6f/16 - OVERLAY_OFFSET, -2f/16 - OVERLAY_OFFSET), new Vector3f(4f/16 + OVERLAY_OFFSET, 6f/16 + OVERLAY_OFFSET, 2f/16 + OVERLAY_OFFSET),
+                        ModelBuilder.boxTexCoords(20f/64, 1 - 48f/texHeight, 8f/64, 12f/texHeight, 4f/64, 4f/texHeight));
+                partMat = new Matrix4f().identity().translate(0, 2f/16, 0);
+                break;
+            case RARM:
+                mb.addCube(new Vector3f((partInfo == PART_ARM_NORMAL ? -2f/16 : -1f/16) - OVERLAY_OFFSET, -10f/16 - OVERLAY_OFFSET, -2f/16 - OVERLAY_OFFSET - ZFIGHT_OFFSET), new Vector3f(2f/16 + OVERLAY_OFFSET, 2f/16 + OVERLAY_OFFSET, 2f/16 + OVERLAY_OFFSET + ZFIGHT_OFFSET),
+                        ModelBuilder.boxTexCoords(44f/64, 1 - 48f/texHeight, partInfo == PART_ARM_NORMAL ? 4f/64 : 3f/64, 12f/texHeight, 4f/64, 4f/texHeight));
+                partMat = new Matrix4f().identity().translate(-6f/16, 6f/16, 0);
+                break;
+            case LARM:
+                mb.addCube(new Vector3f(-2f/16 - OVERLAY_OFFSET, -10f/16 - OVERLAY_OFFSET, -2f/16 - OVERLAY_OFFSET - ZFIGHT_OFFSET), new Vector3f((partInfo == PART_ARM_NORMAL ? 2f/16 : 1f/16) + OVERLAY_OFFSET, 2f/16 + OVERLAY_OFFSET, 2f/16 + OVERLAY_OFFSET + ZFIGHT_OFFSET),
+                        ModelBuilder.boxTexCoords(52f/64, 1 - 64f/64, partInfo == PART_ARM_NORMAL ? 4f/64 : 3f/64, 12f/texHeight, 4f/64, 4f/texHeight));
+                partMat = new Matrix4f().identity().translate(6f/16, 6f/16, 0);
+                break;
+            case RLEG:
+                mb.addCube(new Vector3f(-2f/16 - OVERLAY_OFFSET - ZFIGHT_OFFSET, -12f/16 - OVERLAY_OFFSET, -2f/16 - OVERLAY_OFFSET), new Vector3f(2f/16 + OVERLAY_OFFSET + ZFIGHT_OFFSET, 0f/16 + OVERLAY_OFFSET, 2f/16 + OVERLAY_OFFSET),
+                        ModelBuilder.boxTexCoords(4f/64, 1 - 48f/texHeight, 4f/64, 12f/texHeight, 4f/64, 4f/texHeight));
+                partMat = new Matrix4f().identity().translate(-2f/16, -4f/16, 0);
+                break;
+            case LLEG:
+                mb.addCube(new Vector3f(-2f/16 - OVERLAY_OFFSET - ZFIGHT_OFFSET, -12f/16 - OVERLAY_OFFSET, -2f/16 - OVERLAY_OFFSET), new Vector3f(2f/16 + OVERLAY_OFFSET + ZFIGHT_OFFSET, 0f/16 + OVERLAY_OFFSET, 2f/16 + OVERLAY_OFFSET),
+                        ModelBuilder.boxTexCoords(4f/64, 1 - 64f/64, 4f/64, 12f/texHeight, 4f/64, 4f/texHeight));
+                partMat = new Matrix4f().identity().translate(2f/16, -4f/16, 0);
+                break;
+            default:
+                throw new IllegalArgumentException("Invalid model part specified");
+        }
+
+        verts = mb.getVerts();
+        normals = mb.getNormals();
+        texCoords = mb.getTexCoords();
+        vertCount = mb.getVertCount();
+        normalCount = mb.getNormalCount();
+        texCoordCount = mb.getTexCoordCount();
+    }
+
+    @Override
+    protected float[] getVertices() {
+        return verts;
+    }
+
+    @Override
+    protected float[] getNormals() {
+        return normals;
+    }
+
+    @Override
+    protected float[] getTexCoords() {
+        return texCoords;
+    }
+
+    @Override
+    protected int getVertexCount() {
+        return vertCount;
+    }
+
+    @Override
+    protected int getNormalCount() {
+        return normalCount;
+    }
+
+    @Override
+    protected int getTexCoordCount() {
+        return texCoordCount;
+    }
+
+    @Override
+    public Matrix4f getSuggestedPartMatrix() {
+        return partMat;
+    }
+}
diff --git a/src/main/java/net/minecraft/launcher/SwingUserInterface.java b/src/main/java/net/minecraft/launcher/SwingUserInterface.java
index a00d3dc..b2b1417 100644
--- a/src/main/java/net/minecraft/launcher/SwingUserInterface.java
+++ b/src/main/java/net/minecraft/launcher/SwingUserInterface.java
@@ -106,11 +106,15 @@ public class SwingUserInterface implements MinecraftUserInterface {
                 SwingUserInterface.LOGGER.info("Halting executors");
                 SwingUserInterface.this.minecraftLauncher.getLauncher().getVersionManager().getExecutorService().shutdown();
                 SwingUserInterface.this.minecraftLauncher.getLauncher().getJreManager().getExecutorService().shutdown(); // olauncher - shut down jreManager executor
+
+                launcherPanel.getTabPanel().shutdownSkinEditor(); // olauncher - shut down the skin editor executor
+
                 SwingUserInterface.LOGGER.info("Awaiting termination.");
 
                 try {
                     SwingUserInterface.this.minecraftLauncher.getLauncher().getVersionManager().getExecutorService().awaitTermination(10L, TimeUnit.SECONDS);
                     SwingUserInterface.this.minecraftLauncher.getLauncher().getVersionManager().getExecutorService().awaitTermination(10L, TimeUnit.SECONDS); // olauncher - wait for jreManager executor to stop
+                    launcherPanel.getTabPanel().getSkinEditorService().awaitTermination(10L, TimeUnit.SECONDS); // olauncher - wait for skin editor executor to stop
                 } catch (InterruptedException var3) {
                     SwingUserInterface.LOGGER.info("Termination took too long.");
                 }
diff --git a/src/main/java/net/minecraft/launcher/ui/tabs/LauncherTabPanel.java b/src/main/java/net/minecraft/launcher/ui/tabs/LauncherTabPanel.java
index fe39640..eae4b87 100644
--- a/src/main/java/net/minecraft/launcher/ui/tabs/LauncherTabPanel.java
+++ b/src/main/java/net/minecraft/launcher/ui/tabs/LauncherTabPanel.java
@@ -1,21 +1,43 @@
 package net.minecraft.launcher.ui.tabs;
 
 import java.awt.Component;
-import javax.swing.JTabbedPane;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import javax.swing.*;
+
+import com.mojang.authlib.UserAuthentication;
+import dev.figboot.olauncher.auth.MCProfileInfo;
+import dev.figboot.olauncher.auth.MicrosoftUserAuthentication;
+import dev.figboot.olauncher.skin.ui.SkinEditorTab;
 import net.minecraft.launcher.Launcher;
+import net.minecraft.launcher.profile.ProfileManager;
 
 public class LauncherTabPanel extends JTabbedPane {
     private final Launcher minecraftLauncher;
     private final WebsiteTab blog;
     private final ConsoleTab console;
+    private SkinEditorTab skinEditor;
     private CrashReportTab crashReportTab;
 
+    private ScheduledExecutorService skinEditorService;
+
     public LauncherTabPanel(Launcher var1) {
         super(1);
         this.minecraftLauncher = var1;
         this.blog = new WebsiteTab(var1);
         this.console = new ConsoleTab(var1);
         this.createInterface();
+
+        // olauncher start - handle skin editor tab
+        skinEditorService = new ScheduledThreadPoolExecutor(5, r -> {
+            Thread t = new Thread(r);
+            t.setDaemon(true);
+            return t;
+        });
+
+        minecraftLauncher.getProfileManager().addUserChangedListener((man) -> handleUpdate());
+        minecraftLauncher.getProfileManager().addRefreshedProfilesListener((man) -> handleUpdate());
+        // olauncher end
     }
 
     protected void createInterface() {
@@ -36,6 +58,12 @@ public class LauncherTabPanel extends JTabbedPane {
         return this.console;
     }
 
+    // olauncher start - add skinEditor tab getter
+    public SkinEditorTab getSkinEditor() {
+        return skinEditor;
+    }
+    // olauncher end
+
     public void showConsole() {
         this.setSelectedComponent(this.console);
     }
@@ -67,4 +95,52 @@ public class LauncherTabPanel extends JTabbedPane {
         }
 
     }
+
+    // olauncher start - create skin editor tab when possible
+    public ScheduledExecutorService getSkinEditorService() {
+        return skinEditorService;
+    }
+
+    public void shutdownSkinEditor() {
+        if (skinEditor != null) skinEditor.shutdown();
+        skinEditorService.shutdown();
+    }
+
+    private void removeSkinEditor() {
+        if (skinEditor != null) {
+            skinEditor.shutdown();
+            removeTab("Skin Editor");
+        }
+        skinEditor = null;
+    }
+
+    public void addSkinEditor(MCProfileInfo profile) {
+        if (skinEditor != null && skinEditor.getPlayerUuid().equals(profile.getId())) return;
+
+        removeSkinEditor();
+        skinEditor = new SkinEditorTab(minecraftLauncher, skinEditorService, profile);
+        addTab("Skin Editor", skinEditor);
+    }
+
+    private void handleUpdate() {
+        SwingUtilities.invokeLater(() -> {
+            ProfileManager pman = minecraftLauncher.getProfileManager();
+            String activeUser = pman.getSelectedUser();
+            UserAuthentication auth = pman.getAuthDatabase().getByUUID(activeUser);
+            if (!(auth instanceof MicrosoftUserAuthentication)) {
+                removeSkinEditor();
+                return;
+            }
+
+            MicrosoftUserAuthentication msua = (MicrosoftUserAuthentication)auth;
+            MCProfileInfo profileInfo = msua.getProfileInfo();
+            if (profileInfo == null) {
+                removeSkinEditor();
+                return;
+            }
+
+            addSkinEditor(profileInfo);
+        });
+    }
+    // olauncher end
 }
diff --git a/src/main/resources/dev/figboot/olauncher/skin/ui/frag.glsl b/src/main/resources/dev/figboot/olauncher/skin/ui/frag.glsl
new file mode 100644
index 0000000..95db88c
--- /dev/null
+++ b/src/main/resources/dev/figboot/olauncher/skin/ui/frag.glsl
@@ -0,0 +1,16 @@
+#version 130
+
+uniform float opaqueThresh;
+uniform bool allowTranslucent;
+uniform sampler2D sampler;
+
+in vec2 texCoord;
+in float mul;
+
+out vec4 fragColor;
+
+void main() {
+    vec4 color = texture(sampler, texCoord);
+    color = vec4(color.xyz * mul, color.w);
+    fragColor = vec4(color.xyz, color.w >= opaqueThresh ? 1. : (allowTranslucent ? color.w : 0.));
+}
diff --git a/src/main/resources/dev/figboot/olauncher/skin/ui/vert.glsl b/src/main/resources/dev/figboot/olauncher/skin/ui/vert.glsl
new file mode 100644
index 0000000..762b86c
--- /dev/null
+++ b/src/main/resources/dev/figboot/olauncher/skin/ui/vert.glsl
@@ -0,0 +1,23 @@
+#version 130
+
+uniform mat4 projmat;
+uniform mat4 worldmat;
+uniform mat4 partmat;
+
+uniform vec3 lightPos;
+uniform bool flipNormals;
+
+in vec3 vertPos;
+in vec2 inTexCoord;
+in vec3 normal;
+
+out vec2 texCoord;
+out float mul;
+
+void main() {
+    gl_Position = projmat * worldmat * partmat * vec4(vertPos, 1.0);
+    texCoord = inTexCoord;
+    vec4 realNormal = vec4(normal, 1.);
+    if (flipNormals) realNormal = -realNormal;
+    mul = (dot(normalize((worldmat * partmat * realNormal).xyz), lightPos) + 1) / 2;
+}
-- 
2.35.1

